static char *lexer_h_headers[] = {
    "stddef.h"
};

static char *lexer_c_headers[] = {
    "stdio.h",
    "stdlib.h",
    "string.h",
    "unistd.h",
    "fcntl.h"
};

static char lexer_h[] =
"typedef struct {\n"
"    int fd;\n"
"    int cur_buf;\n"
"    char buf[8192];\n"
"    char *symtab;\n"
"    size_t max_bytes, num_bytes;\n"
"    size_t buf_off, read_len;\n"
"    size_t cur_line, cur_chr;\n"
"} lexer_t;\n"
"\n"
"typedef enum { LEX_ERROR = -1, LEX_SUCCESS = 0, LEX_EOF = 1 } lexer_res_t;\n"
"\n"
"lexer_t* lexer_create(const char *filename);\n"
"lexer_res_t lexer_next_tok(lexer_t *lex, lexeme_t *m);\n"
"void lexer_free(lexer_t *lex);\n";

static char lexer_c[] =
"lexer_t* lexer_create(const char *filename) {\n"
"    lexer_t *lex;\n"
"    int fd = -1;\n"
"\n"
"    lex = malloc(sizeof(lexer_t));\n"
"    if(!lex) {\n"
"        perror(\"malloc\");\n"
"        goto exit;\n"
"    }\n"
"    lex->symtab = NULL;\n"
"\n"
"    fd = open(filename, O_RDONLY);\n"
"    if(fd < 0) {\n"
"        perror(\"open\");\n"
"        goto exit;\n"
"    }\n"
"    lex->fd = fd;\n"
"\n"
"    lex->cur_buf = 1;\n"
"    lex->buf_off = 0;\n"
"    lex->read_len = 0;\n"
"    lex->cur_line = 1;\n"
"    lex->cur_chr = 1;\n"
"\n"
"    lex->max_bytes = 32;\n"
"    lex->num_bytes = 0;\n"
"    lex->symtab = malloc(lex->max_bytes);\n"
"    if(!lex->symtab) {\n"
"        perror(\"malloc\");\n"
"        goto exit;\n"
"    }\n"
"\n"
"    return lex;\n"
"exit:\n"
"    if(lex) {\n"
"        if(lex->symtab) free(lex->symtab);\n"
"        free(lex);\n"
"    }\n"
"    if(fd >= 0) close(fd);\n"
"    return NULL;\n"
"}\n"
"\n"
"lexer_res_t lexer_next_tok(lexer_t *lex, lexeme_t *m) {\n"
"    int cur_state = 0, next_state = -1;\n"
"    int (*target)(lexeme_t*) = NULL;\n"
"    int (*next_target)(lexeme_t*) = NULL;\n"
"    size_t lexeme_len = 0;\n"
"    size_t targ_off, targ_line, targ_chr;\n"
"    int targ_buf;\n"
"    char *buf = lex->buf + (lex->cur_buf*sizeof(lex->buf)/2);\n"
"    unsigned char c = 0;\n"
"    ssize_t read_len = 0;\n"
"\n"
"    for(;;) {\n"
"        for(size_t i = lex->buf_off; i < lex->read_len; i++) {\n"
"            c = buf[i];\n"
"\n"
"            if(next_target) {\n"
"                target = next_target;\n"
"                targ_buf = lex->cur_buf;\n"
"                targ_off = i;\n"
"                targ_line = lex->cur_line;\n"
"                targ_chr = lex->cur_chr;\n"
"                next_target = NULL;\n"
"            }\n"
"\n"
"            next_state = states[cur_state*255 + c];\n"
"\n"
"            if(lex->num_bytes == lex->max_bytes) {\n"
"                lex->max_bytes <<= 1;\n"
"                char *tmp = realloc(lex->symtab, lex->max_bytes);\n"
"                if(!tmp) {\n"
"                    perror(\"realloc\");\n"
"                    return LEX_ERROR;\n"
"                }\n"
"                lex->symtab = tmp;\n"
"            }\n"
"            lex->symtab[lex->num_bytes++] = next_state == 0 ? 0 : c;\n"
"\n"
"            if(next_state == 0)\n"
"                break;\n"
"            next_target = targets[next_state];\n"
"\n"
"            cur_state = next_state;\n"
"            if(c == '\\n') {\n"
"                lex->cur_line++;\n"
"                lex->cur_chr = 0;\n"
"            }\n"
"            lex->cur_chr++;\n"
"            lex->buf_off++;\n"
"            lexeme_len++;\n"
"        }\n"
"\n"
"        if(lex->buf_off == lex->read_len) {\n"
"            lex->cur_buf = !lex->cur_buf;\n"
"            buf = lex->buf + (lex->cur_buf*sizeof(lex->buf)/2);\n"
"            read_len = read(lex->fd, buf, sizeof(lex->buf)/2);\n"
"            if(read_len < 0) {\n"
"                perror(\"read\");\n"
"                return LEX_ERROR;\n"
"            }\n"
"            lex->read_len = read_len;\n"
"            lex->buf_off=0;\n"
"        }\n"
"\n"
"        if(next_state == 0 || lex->read_len == 0) {\n"
"            if(target) {\n"
"                lex->num_bytes = 0;\n"
"                m->str = lex->symtab;\n"
"                m->str_len = lexeme_len-1;\n"
"                int class = target(m);\n"
"                if(class < 0) {\n"
"                    return LEX_ERROR;\n"
"                } else if(class == 0) {\n"
"                    cur_state = 0;\n"
"                    if(lex->read_len == 0)\n"
"                        return LEX_EOF;\n"
"                } else {\n"
"                    m->class = class;\n"
"                    lex->cur_buf = targ_buf;\n"
"                    lex->buf_off = targ_off;\n"
"                    lex->cur_line = targ_line;\n"
"                    lex->cur_chr = targ_chr;\n"
"                    return LEX_SUCCESS;\n"
"                }\n"
"                target = NULL;\n"
"            } else if(next_state == 0) {\n"
"                fprintf(stderr, \"%lu:%lu unexpected %c\\n\", lex->cur_line, lex->cur_chr, c);\n"
"                return LEX_ERROR;\n"
"            } else {\n"
"                return LEX_EOF;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    return LEX_ERROR;\n"
"}\n"
"\n"
"void lexer_free(lexer_t *lex) {\n"
"    close(lex->fd);\n"
"    free(lex->symtab);\n"
"    free(lex);\n"
"}\n";
